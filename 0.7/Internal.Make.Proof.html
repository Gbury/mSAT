<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="Up" href="Internal.Make.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Log" rel="Chapter" href="Log.html">
<link title="Formula_intf" rel="Chapter" href="Formula_intf.html">
<link title="Theory_intf" rel="Chapter" href="Theory_intf.html">
<link title="Plugin_intf" rel="Chapter" href="Plugin_intf.html">
<link title="Expr_intf" rel="Chapter" href="Expr_intf.html">
<link title="Res_intf" rel="Chapter" href="Res_intf.html">
<link title="Solver_types_intf" rel="Chapter" href="Solver_types_intf.html">
<link title="Solver_intf" rel="Chapter" href="Solver_intf.html">
<link title="Tseitin_intf" rel="Chapter" href="Tseitin_intf.html">
<link title="Res" rel="Chapter" href="Res.html">
<link title="Internal" rel="Chapter" href="Internal.html">
<link title="External" rel="Chapter" href="External.html">
<link title="Solver_types" rel="Chapter" href="Solver_types.html">
<link title="Solver" rel="Chapter" href="Solver.html">
<link title="Mcsolver" rel="Chapter" href="Mcsolver.html">
<link title="Tseitin" rel="Chapter" href="Tseitin.html">
<link title="Dot" rel="Chapter" href="Dot.html">
<link title="Coq" rel="Chapter" href="Coq.html">
<link title="Dedukti" rel="Chapter" href="Dedukti.html">
<link title="Backend_intf" rel="Chapter" href="Backend_intf.html">
<link title="Sat" rel="Chapter" href="Sat.html"><link title="Type declarations" rel="Section" href="#3_Typedeclarations">
<link title="Resolution helpers" rel="Section" href="#3_Resolutionhelpers">
<link title="Proof building functions" rel="Section" href="#3_Proofbuildingfunctions">
<link title="Proof Nodes" rel="Section" href="#3_ProofNodes">
<link title="Proof Manipulation" rel="Section" href="#3_ProofManipulation">
<link title="Misc" rel="Section" href="#3_Misc">
<link title="Unsafe" rel="Section" href="#3_Unsafe">
<title>mSAT doc : Internal.Make.Proof</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="Internal.Make.html" title="Internal.Make">Up</a>
&nbsp;</div>
<h1>Module <a href="type_Internal.Make.Proof.html">Internal.Make.Proof</a></h1>

<pre><span id="MODULEProof"><span class="keyword">module</span> Proof</span>: <code class="type"><a href="Res.S.html">Res.S</a></code><code class="type">  with module St = St</code></pre><hr width="100%">
<p>Signature for a module handling proof by resolution from sat solving traces</p>

<pre><span id="MODULESt"><span class="keyword">module</span> <a href="Res_intf.S.St.html">St</a></span>: <code class="type"><a href="Solver_types.S.html">Solver_types.S</a></code><code class="type"> </code></pre><div class="info">
<p>Module defining atom and clauses</p>

</div>
<h4 id="3_Typedeclarations">Type declarations</h4>
<pre><span id="EXCEPTIONInsuficient_hyps"><span class="keyword">exception</span> Insuficient_hyps</span></pre>
<div class="info ">
<div class="info-desc">
<p>Raised when a complete resolution derivation cannot be found using the current hypotheses.</p>
</div>
</div>

<pre><span id="TYPEatom"><span class="keyword">type</span> <code class="type"></code>atom</span> = <code class="type">St.atom</code> </pre>


<pre><span id="TYPElemma"><span class="keyword">type</span> <code class="type"></code>lemma</span> = <code class="type">St.proof</code> </pre>


<pre><span id="TYPEclause"><span class="keyword">type</span> <code class="type"></code>clause</span> = <code class="type">St.clause</code> </pre>
<div class="info ">
<div class="info-desc">
<p>Abstract types for atoms, clauses and theory-specific lemmas</p>
</div>
</div>


<pre><span id="TYPEproof"><span class="keyword">type</span> <code class="type"></code>proof</span> </pre>
<div class="info ">
<div class="info-desc">
<p>Lazy type for proof trees. Proofs are persistent objects, and can be
      extended to proof nodes using functions defined later.</p>
</div>
</div>


<pre><code><span id="TYPEproof_node"><span class="keyword">type</span> <code class="type"></code>proof_node</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTproof_node.conclusion">conclusion</span>&nbsp;: <code class="type"><a href="Res_intf.S.html#TYPEclause">clause</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The conclusion of the proof</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTproof_node.step">step</span>&nbsp;: <code class="type"><a href="Res_intf.S.html#TYPEstep">step</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The reasoning step used to prove the conclusion</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info ">
<div class="info-desc">
<p>A proof can be expanded into a proof node, which show the first step of the proof.</p>
</div>
</div>


<pre><code><span id="TYPEstep"><span class="keyword">type</span> <code class="type"></code>step</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstep.Hypothesis"><span class="constructor">Hypothesis</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The conclusion is a user-provided hypothesis</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstep.Assumption"><span class="constructor">Assumption</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The conclusion has been locally assumed by the user</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstep.Lemma"><span class="constructor">Lemma</span></span> <span class="keyword">of</span> <code class="type"><a href="Res_intf.S.html#TYPElemma">lemma</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The conclusion is a tautology provided by the theory, with associated proof</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstep.Duplicate"><span class="constructor">Duplicate</span></span> <span class="keyword">of</span> <code class="type"><a href="Res_intf.S.html#TYPEproof">proof</a> * <a href="Res_intf.S.html#TYPEatom">atom</a> list</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The conclusion is obtained by eliminating multiple occurences of the atom in
        the conclusion of the provided proof.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstep.Resolution"><span class="constructor">Resolution</span></span> <span class="keyword">of</span> <code class="type"><a href="Res_intf.S.html#TYPEproof">proof</a> * <a href="Res_intf.S.html#TYPEproof">proof</a> * <a href="Res_intf.S.html#TYPEatom">atom</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The conclusion can be deduced by performing a resolution between the conclusions
        of the two given proofs. The atom on which to perform the resolution is also given.</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
<div class="info-desc">
<p>The type of reasoning steps allowed in a proof.</p>
</div>
</div>

<h4 id="3_Resolutionhelpers">Resolution helpers</h4>
<pre><span id="VALto_list"><span class="keyword">val</span> to_list</span> : <code class="type"><a href="Res_intf.S.html#TYPEclause">clause</a> -> <a href="Res_intf.S.html#TYPEatom">atom</a> list</code></pre><div class="info ">
<div class="info-desc">
<p>Returns the sorted list of atoms of a clause.</p>
</div>
</div>

<pre><span id="VALmerge"><span class="keyword">val</span> merge</span> : <code class="type"><a href="Res_intf.S.html#TYPEatom">atom</a> list -> <a href="Res_intf.S.html#TYPEatom">atom</a> list -> <a href="Res_intf.S.html#TYPEatom">atom</a> list</code></pre><div class="info ">
<div class="info-desc">
<p>Merge two sorted atom list using a suitable comparison function.</p>
</div>
</div>

<pre><span id="VALresolve"><span class="keyword">val</span> resolve</span> : <code class="type"><a href="Res_intf.S.html#TYPEatom">atom</a> list -> <a href="Res_intf.S.html#TYPEatom">atom</a> list * <a href="Res_intf.S.html#TYPEatom">atom</a> list</code></pre><div class="info ">
<div class="info-desc">
<p>Performs a "resolution step" on a sorted list of atoms.
      <code class="code">resolve (List.merge l1 l2)</code> where <code class="code">l1</code> and <code class="code">l2</code> are sorted atom lists should return the pair
      <code class="code">[a], l'</code>, where <code class="code">l'</code> is the result of the resolution of <code class="code">l1</code> and <code class="code">l2</code> over <code class="code">a</code>.</p>
</div>
</div>
<h4 id="3_Proofbuildingfunctions">Proof building functions</h4>
<pre><span id="VALprove"><span class="keyword">val</span> prove</span> : <code class="type"><a href="Res_intf.S.html#TYPEclause">clause</a> -> <a href="Res_intf.S.html#TYPEproof">proof</a></code></pre><div class="info ">
<div class="info-desc">
<p>Given a clause, return a proof of that clause.</p>
</div>
<ul class="info-attributes">
<li><b>Raises</b> <code>Insuficient_hyps</code> if it does not succeed.</li>
</ul>
</div>

<pre><span id="VALprove_unsat"><span class="keyword">val</span> prove_unsat</span> : <code class="type"><a href="Res_intf.S.html#TYPEclause">clause</a> -> <a href="Res_intf.S.html#TYPEproof">proof</a></code></pre><div class="info ">
<div class="info-desc">
<p>Given a conflict clause <code class="code">c</code>, returns a proof of the empty clause.</p>
</div>
<ul class="info-attributes">
<li><b>Raises</b> <code>Insuficient_hyps</code> if it does not succeed.</li>
</ul>
</div>

<pre><span id="VALprove_atom"><span class="keyword">val</span> prove_atom</span> : <code class="type"><a href="Res_intf.S.html#TYPEatom">atom</a> -> <a href="Res_intf.S.html#TYPEproof">proof</a> option</code></pre><div class="info ">
<div class="info-desc">
<p>Given an atom <code class="code">a</code>, returns a proof of the clause <code class="code">[a]</code> if <code class="code">a</code> is true at level 0</p>
</div>
</div>
<h4 id="3_ProofNodes">Proof Nodes</h4>
<pre><span id="VALparents"><span class="keyword">val</span> parents</span> : <code class="type"><a href="Res_intf.S.html#TYPEstep">step</a> -> <a href="Res_intf.S.html#TYPEproof">proof</a> list</code></pre><div class="info ">
<div class="info-desc">
<p>Returns the parents of a proof node.</p>
</div>
</div>

<pre><span id="VALis_leaf"><span class="keyword">val</span> is_leaf</span> : <code class="type"><a href="Res_intf.S.html#TYPEstep">step</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p>Returns wether the the proof node is a leaf, i.e. an hypothesis,
      an assumption, or a lemma.
      <code class="code">true</code> if and only if <a href="Res_intf.S.html#VALparents"><code class="code">Res_intf.S.parents</code></a> returns the empty list.</p>
</div>
</div>

<pre><span id="VALexpl"><span class="keyword">val</span> expl</span> : <code class="type"><a href="Res_intf.S.html#TYPEstep">step</a> -> string</code></pre><div class="info ">
<div class="info-desc">
<p>Returns a short string description for the proof step; for instance
      <code class="code">"hypothesis"</code> for a <code class="code">Hypothesis</code>
      (it currently returns the variant name in lowercase).</p>
</div>
</div>
<h4 id="3_ProofManipulation">Proof Manipulation</h4>
<pre><span id="VALexpand"><span class="keyword">val</span> expand</span> : <code class="type"><a href="Res_intf.S.html#TYPEproof">proof</a> -> <a href="Res_intf.S.html#TYPEproof_node">proof_node</a></code></pre><div class="info ">
<div class="info-desc">
<p>Return the proof step at the root of a given proof.</p>
</div>
</div>

<pre><span id="VALfold"><span class="keyword">val</span> fold</span> : <code class="type">('a -> <a href="Res_intf.S.html#TYPEproof_node">proof_node</a> -> 'a) -> 'a -> <a href="Res_intf.S.html#TYPEproof">proof</a> -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">fold f acc p</code>, fold <code class="code">f</code> over the proof <code class="code">p</code> and all its node. It is guaranteed that
      <code class="code">f</code> is executed exactly once on each proof node in the tree, and that the execution of
      <code class="code">f</code> on a proof node happens after the execution on the parents of the nodes.</p>
</div>
</div>

<pre><span id="VALunsat_core"><span class="keyword">val</span> unsat_core</span> : <code class="type"><a href="Res_intf.S.html#TYPEproof">proof</a> -> <a href="Res_intf.S.html#TYPEclause">clause</a> list</code></pre><div class="info ">
<div class="info-desc">
<p>Returns the unsat_core of the given proof, i.e the lists of conclusions of all leafs of the proof.
      More efficient than using the <code class="code">fold</code> function since it has access to the internal representation of proofs</p>
</div>
</div>
<h4 id="3_Misc">Misc</h4>
<pre><span id="VALcheck"><span class="keyword">val</span> check</span> : <code class="type"><a href="Res_intf.S.html#TYPEproof">proof</a> -> unit</code></pre><div class="info ">
<div class="info-desc">
<p>Check the contents of a proof. Mainly for internal use</p>
</div>
</div>

<pre><span id="VALprint_clause"><span class="keyword">val</span> print_clause</span> : <code class="type">Format.formatter -> <a href="Res_intf.S.html#TYPEclause">clause</a> -> unit</code></pre><div class="info ">
<div class="info-desc">
<p>A nice looking printer for clauses, which sort the atoms before printing.</p>
</div>
</div>
<h4 id="3_Unsafe">Unsafe</h4>
<pre><span id="MODULEH"><span class="keyword">module</span> <a href="Res_intf.S.H.html">H</a></span>: <code class="type">Hashtbl.S</code><code class="type">  with type key = clause</code></pre><div class="info">
<p>Hashtable over proofs.</p>

</div>
</body></html>