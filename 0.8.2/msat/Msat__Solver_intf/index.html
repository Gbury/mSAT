<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Msat__Solver_intf (msat.Msat__Solver_intf)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">msat</a> &#x00BB; Msat__Solver_intf</nav><h1>Module <code>Msat__Solver_intf</code></h1><p>Interface for Solvers</p><p>This modules defines the safe external interface for solvers. Solvers that implements this interface can be obtained using the <code>Make</code> functor in <code>Solver</code> or <code>Mcsolver</code>.</p></header><dl><dt class="spec type" id="type-printer"><a href="#type-printer" class="anchor"></a><code><span class="keyword">type</span> <span>'a printer</span></code><code> = Format.formatter <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec type" id="type-sat_state"><a href="#type-sat_state" class="anchor"></a><code><span class="keyword">type</span> <span>('term, 'form, 'value) sat_state</span></code><code> = </code><code>{</code><table class="record"><tr id="type-sat_state.eval" class="anchored"><td class="def field"><a href="#type-sat_state.eval" class="anchor"></a><code>eval : <span class="type-var">'form</span> <span>&#45;&gt;</span> bool;</code></td><td class="doc"><p>Returns the valuation of a formula in the current state of the sat solver.</p><dl><dt>raises UndecidedLit</dt><dd><p>if the literal is not decided</p></dd></dl></td></tr><tr id="type-sat_state.eval_level" class="anchored"><td class="def field"><a href="#type-sat_state.eval_level" class="anchor"></a><code>eval_level : <span class="type-var">'form</span> <span>&#45;&gt;</span> bool * int;</code></td><td class="doc"><p>Return the current assignement of the literals, as well as its decision level. If the level is 0, then it is necessary for the atom to have this value; otherwise it is due to choices that can potentially be backtracked.</p><dl><dt>raises UndecidedLit</dt><dd><p>if the literal is not decided</p></dd></dl></td></tr><tr id="type-sat_state.iter_trail" class="anchored"><td class="def field"><a href="#type-sat_state.iter_trail" class="anchor"></a><code>iter_trail : <span>(<span class="type-var">'form</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'term</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit;</code></td><td class="doc"><p>Iter thorugh the formulas and terms in order of decision/propagation (starting from the first propagation, to the last propagation).</p></td></tr><tr id="type-sat_state.model" class="anchored"><td class="def field"><a href="#type-sat_state.model" class="anchor"></a><code>model : unit <span>&#45;&gt;</span> <span><span>(<span class="type-var">'term</span> * <span class="type-var">'value</span>)</span> list</span>;</code></td><td class="doc"><p>Returns the model found if the formula is satisfiable.</p></td></tr></table><code>}</code></dt><dd><p>The type of values returned when the solver reaches a SAT state.</p></dd></dl><dl><dt class="spec type" id="type-unsat_state"><a href="#type-unsat_state" class="anchor"></a><code><span class="keyword">type</span> <span>('atom, 'clause, 'proof) unsat_state</span></code><code> = </code><code>{</code><table class="record"><tr id="type-unsat_state.unsat_conflict" class="anchored"><td class="def field"><a href="#type-unsat_state.unsat_conflict" class="anchor"></a><code>unsat_conflict : unit <span>&#45;&gt;</span> <span class="type-var">'clause</span>;</code></td><td class="doc"><p>Returns the unsat clause found at the toplevel</p></td></tr><tr id="type-unsat_state.get_proof" class="anchored"><td class="def field"><a href="#type-unsat_state.get_proof" class="anchor"></a><code>get_proof : unit <span>&#45;&gt;</span> <span class="type-var">'proof</span>;</code></td><td class="doc"><p>returns a persistent proof of the empty clause from the Unsat result.</p></td></tr><tr id="type-unsat_state.unsat_assumptions" class="anchored"><td class="def field"><a href="#type-unsat_state.unsat_assumptions" class="anchor"></a><code>unsat_assumptions : unit <span>&#45;&gt;</span> <span><span class="type-var">'atom</span> list</span>;</code></td><td class="doc"><p>Subset of assumptions responsible for &quot;unsat&quot;</p></td></tr></table><code>}</code></dt><dd><p>The type of values returned when the solver reaches an UNSAT state.</p></dd></dl><dl><dt class="spec type" id="type-export"><a href="#type-export" class="anchor"></a><code><span class="keyword">type</span> <span>'clause export</span></code><code> = </code><code>{</code><table class="record"><tr id="type-export.hyps" class="anchored"><td class="def field"><a href="#type-export.hyps" class="anchor"></a><code>hyps : <span><span class="type-var">'clause</span> <a href="../Msat/Vec/index.html#type-t">Msat.Vec.t</a></span>;</code></td></tr><tr id="type-export.history" class="anchored"><td class="def field"><a href="#type-export.history" class="anchor"></a><code>history : <span><span class="type-var">'clause</span> <a href="../Msat/Vec/index.html#type-t">Msat.Vec.t</a></span>;</code></td></tr></table><code>}</code></dt><dd><p>Export internal state</p></dd></dl><dl><dt class="spec type" id="type-negated"><a href="#type-negated" class="anchor"></a><code><span class="keyword">type</span> negated</code><code> = </code><table class="variant"><tr id="type-negated.Negated" class="anchored"><td class="def constructor"><a href="#type-negated.Negated" class="anchor"></a><code>| </code><code><span class="constructor">Negated</span></code></td><td class="doc"><p>changed sign</p></td></tr><tr id="type-negated.Same_sign" class="anchored"><td class="def constructor"><a href="#type-negated.Same_sign" class="anchor"></a><code>| </code><code><span class="constructor">Same_sign</span></code></td><td class="doc"><p>kept sign</p></td></tr></table></dt><dd><p>This type is used during the normalisation of formulas. See <span class="xref-unresolved" title="unresolved reference to &quot;Expr_intf.S.norm&quot;"><span class="xref-unresolved" title="unresolved reference to &quot;Expr_intf.S&quot;"><code>Expr_intf</code>.S</span>.norm</span> for more details.</p></dd></dl><dl><dt class="spec type" id="type-eval_res"><a href="#type-eval_res" class="anchor"></a><code><span class="keyword">type</span> <span>'term eval_res</span></code><code> = </code><table class="variant"><tr id="type-eval_res.Unknown" class="anchored"><td class="def constructor"><a href="#type-eval_res.Unknown" class="anchor"></a><code>| </code><code><span class="constructor">Unknown</span></code></td><td class="doc"><p>The given formula does not have an evaluation</p></td></tr><tr id="type-eval_res.Valued" class="anchored"><td class="def constructor"><a href="#type-eval_res.Valued" class="anchor"></a><code>| </code><code><span class="constructor">Valued</span> <span class="keyword">of</span> bool * <span><span class="type-var">'term</span> list</span></code></td><td class="doc"><p>The given formula can be evaluated to the given bool. The list of terms to give is the list of terms that were effectively used for the evaluation.</p></td></tr></table></dt><dd><p>The type of evaluation results for a given formula. For instance, let's suppose we want to evaluate the formula <code>x * y = 0</code>, the following result are correct:</p><ul><li><code>Unknown</code> if neither <code>x</code> nor <code>y</code> are assigned to a value</li><li><code>Valued (true, [x])</code> if <code>x</code> is assigned to <code>0</code></li><li><code>Valued (true, [y])</code> if <code>y</code> is assigned to <code>0</code></li><li><code>Valued (false, [x; y])</code> if <code>x</code> and <code>y</code> are assigned to 1 (or any non-zero number)</li></ul></dd></dl><dl><dt class="spec type" id="type-assumption"><a href="#type-assumption" class="anchor"></a><code><span class="keyword">type</span> <span>('term, 'formula, 'value) assumption</span></code><code> = </code><table class="variant"><tr id="type-assumption.Lit" class="anchored"><td class="def constructor"><a href="#type-assumption.Lit" class="anchor"></a><code>| </code><code><span class="constructor">Lit</span> <span class="keyword">of</span> <span class="type-var">'formula</span></code></td><td class="doc"><p>The given formula is asserted true by the solver</p></td></tr><tr id="type-assumption.Assign" class="anchored"><td class="def constructor"><a href="#type-assumption.Assign" class="anchor"></a><code>| </code><code><span class="constructor">Assign</span> <span class="keyword">of</span> <span class="type-var">'term</span> * <span class="type-var">'value</span></code></td><td class="doc"><p>The term is assigned to the value</p></td></tr></table></dt><dd><p>Asusmptions made by the core SAT solver.</p></dd></dl><dl><dt class="spec type" id="type-reason"><a href="#type-reason" class="anchor"></a><code><span class="keyword">type</span> <span>('term, 'formula, 'proof) reason</span></code><code> = </code><table class="variant"><tr id="type-reason.Eval" class="anchored"><td class="def constructor"><a href="#type-reason.Eval" class="anchor"></a><code>| </code><code><span class="constructor">Eval</span> <span class="keyword">of</span> <span><span class="type-var">'term</span> list</span></code></td><td class="doc"><p>The formula can be evalutaed using the terms in the list</p></td></tr><tr id="type-reason.Consequence" class="anchored"><td class="def constructor"><a href="#type-reason.Consequence" class="anchor"></a><code>| </code><code><span class="constructor">Consequence</span> <span class="keyword">of</span> unit <span>&#45;&gt;</span> <span><span class="type-var">'formula</span> list</span> * <span class="type-var">'proof</span></code></td><td class="doc"><p><code>Consequence (l, p)</code> means that the formulas in <code>l</code> imply the propagated formula <code>f</code>. The proof should be a proof of the clause &quot;<code>l</code> implies <code>f</code>&quot;.</p><p>invariant: in <code>Consequence (fun () -&gt; l,p)</code>, all elements of <code>l</code> must be true in the current trail.</p><p><b>note</b> on lazyiness: the justification is suspended (using <code>unit -&gt; …</code>) to avoid potentially costly computations that might never be used if this literal is backtracked without participating in a conflict. Therefore the function that produces <code>(l,p)</code> needs only be safe in trails (partial models) that are conservative extensions of the current trail. If the theory isn't robust w.r.t. extensions of the trail (e.g. if its internal state undergoes significant changes), it can be easier to produce the explanation eagerly when propagating, and then use <code>Consequence (fun () -&gt; expl, proof)</code> with the already produced <code>(expl,proof)</code> tuple.</p></td></tr></table></dt><dd><p>The type of reasons for propagations of a formula <code>f</code>.</p></dd></dl><dl><dt class="spec type" id="type-lbool"><a href="#type-lbool" class="anchor"></a><code><span class="keyword">type</span> lbool</code><code> = </code><table class="variant"><tr id="type-lbool.L_true" class="anchored"><td class="def constructor"><a href="#type-lbool.L_true" class="anchor"></a><code>| </code><code><span class="constructor">L_true</span></code></td></tr><tr id="type-lbool.L_false" class="anchored"><td class="def constructor"><a href="#type-lbool.L_false" class="anchor"></a><code>| </code><code><span class="constructor">L_false</span></code></td></tr><tr id="type-lbool.L_undefined" class="anchored"><td class="def constructor"><a href="#type-lbool.L_undefined" class="anchor"></a><code>| </code><code><span class="constructor">L_undefined</span></code></td><td class="doc"><p>Valuation of an atom</p></td></tr></table></dt><dt class="spec type" id="type-acts"><a href="#type-acts" class="anchor"></a><code><span class="keyword">type</span> <span>('term, 'formula, 'value, 'proof) acts</span></code><code> = </code><code>{</code><table class="record"><tr id="type-acts.acts_iter_assumptions" class="anchored"><td class="def field"><a href="#type-acts.acts_iter_assumptions" class="anchor"></a><code>acts_iter_assumptions : <span>(<span><span>(<span class="type-var">'term</span>, <span class="type-var">'formula</span>, <span class="type-var">'value</span>)</span> <a href="index.html#type-assumption">assumption</a></span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit;</code></td><td class="doc"><p>Traverse the new assumptions on the boolean trail.</p></td></tr><tr id="type-acts.acts_eval_lit" class="anchored"><td class="def field"><a href="#type-acts.acts_eval_lit" class="anchor"></a><code>acts_eval_lit : <span class="type-var">'formula</span> <span>&#45;&gt;</span> <a href="index.html#type-lbool">lbool</a>;</code></td><td class="doc"><p>Obtain current value of the given literal</p></td></tr><tr id="type-acts.acts_mk_lit" class="anchored"><td class="def field"><a href="#type-acts.acts_mk_lit" class="anchor"></a><code>acts_mk_lit : <span class="type-var">'formula</span> <span>&#45;&gt;</span> unit;</code></td><td class="doc"><p>Map the given formula to a literal, which will be decided by the SAT solver.</p></td></tr><tr id="type-acts.acts_mk_term" class="anchored"><td class="def field"><a href="#type-acts.acts_mk_term" class="anchor"></a><code>acts_mk_term : <span class="type-var">'term</span> <span>&#45;&gt;</span> unit;</code></td><td class="doc"><p>Map the given term (and its subterms) to decision variables, for the MCSAT solver to decide.</p></td></tr><tr id="type-acts.acts_add_clause" class="anchored"><td class="def field"><a href="#type-acts.acts_add_clause" class="anchor"></a><code>acts_add_clause : <span>?&#8288;keep:bool</span> <span>&#45;&gt;</span> <span><span class="type-var">'formula</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'proof</span> <span>&#45;&gt;</span> unit;</code></td><td class="doc"><p>Add a clause to the solver.</p><dl><dt>parameter keep</dt><dd><p>if true, the clause will be kept by the solver. Otherwise the solver is allowed to GC the clause and propose this partial model again.</p></dd></dl></td></tr><tr id="type-acts.acts_raise_conflict" class="anchored"><td class="def field"><a href="#type-acts.acts_raise_conflict" class="anchor"></a><code>acts_raise_conflict : b. <span><span class="type-var">'formula</span> list</span> <span>&#45;&gt;</span> <span class="type-var">'proof</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>;</code></td><td class="doc"><p>Raise a conflict, yielding control back to the solver. The list of atoms must be a valid theory lemma that is false in the current trail.</p></td></tr><tr id="type-acts.acts_propagate" class="anchored"><td class="def field"><a href="#type-acts.acts_propagate" class="anchor"></a><code>acts_propagate : <span class="type-var">'formula</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'term</span>, <span class="type-var">'formula</span>, <span class="type-var">'proof</span>)</span> <a href="index.html#type-reason">reason</a></span> <span>&#45;&gt;</span> unit;</code></td><td class="doc"><p>Propagate a formula, i.e. the theory can evaluate the formula to be true (see the definition of <a href="index.html#type-eval_res"><code>eval_res</code></a></p></td></tr></table><code>}</code></dt><dd><p>The type for a slice of assertions to assume/propagate in the theory.</p></dd></dl><dl><dt class="spec type" id="type-gadt_eq"><a href="#type-gadt_eq" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'b) gadt_eq</span></code><code> = </code><table class="variant"><tr id="type-gadt_eq.GADT_EQ" class="anchored"><td class="def constructor"><a href="#type-gadt_eq.GADT_EQ" class="anchor"></a><code>| </code><code><span class="constructor">GADT_EQ</span> : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span> <a href="index.html#type-gadt_eq">gadt_eq</a></span></code></td></tr></table></dt><dt class="spec type" id="type-void"><a href="#type-void" class="anchor"></a><code><span class="keyword">type</span> void</code><code> = <span><span>(unit, bool)</span> <a href="index.html#type-gadt_eq">gadt_eq</a></span></code></dt><dd><p>A provably empty type</p></dd></dl><dl><dt class="spec exception" id="exception-No_proof"><a href="#exception-No_proof" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">No_proof</span></code></dt></dl><div class="spec module-type" id="module-type-FORMULA"><a href="#module-type-FORMULA" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-FORMULA/index.html">FORMULA</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module-type" id="module-type-EXPR"><a href="#module-type-EXPR" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-EXPR/index.html">EXPR</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Formulas and Terms required for mcSAT</p></dd></dl><dl><dt class="spec module-type" id="module-type-PLUGIN_CDCL_T"><a href="#module-type-PLUGIN_CDCL_T" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-PLUGIN_CDCL_T/index.html">PLUGIN_CDCL_T</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Signature for theories to be given to the CDCL(T) solver</p></dd></dl><dl><dt class="spec module-type" id="module-type-PLUGIN_MCSAT"><a href="#module-type-PLUGIN_MCSAT" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-PLUGIN_MCSAT/index.html">PLUGIN_MCSAT</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Signature for theories to be given to the Model Constructing Solver.</p></dd></dl><dl><dt class="spec module-type" id="module-type-PLUGIN_SAT"><a href="#module-type-PLUGIN_SAT" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-PLUGIN_SAT/index.html">PLUGIN_SAT</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Signature for pure SAT solvers</p></dd></dl><div class="spec module-type" id="module-type-PROOF"><a href="#module-type-PROOF" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-PROOF/index.html">PROOF</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The external interface implemented by safe solvers, such as the one created by the <span class="xref-unresolved" title="unresolved reference to &quot;Solver.Make&quot;"><code>Solver</code>.Make</span> and <span class="xref-unresolved" title="unresolved reference to &quot;Mcsolver.Make&quot;"><code>Mcsolver</code>.Make</span> functors.</p></dd></dl></div></body></html>