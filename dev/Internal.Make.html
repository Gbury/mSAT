<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="Up" href="Internal.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Log" rel="Chapter" href="Log.html">
<link title="Formula_intf" rel="Chapter" href="Formula_intf.html">
<link title="Theory_intf" rel="Chapter" href="Theory_intf.html">
<link title="Plugin_intf" rel="Chapter" href="Plugin_intf.html">
<link title="Expr_intf" rel="Chapter" href="Expr_intf.html">
<link title="Res_intf" rel="Chapter" href="Res_intf.html">
<link title="Solver_types_intf" rel="Chapter" href="Solver_types_intf.html">
<link title="Solver_intf" rel="Chapter" href="Solver_intf.html">
<link title="Tseitin_intf" rel="Chapter" href="Tseitin_intf.html">
<link title="Res" rel="Chapter" href="Res.html">
<link title="Internal" rel="Chapter" href="Internal.html">
<link title="External" rel="Chapter" href="External.html">
<link title="Solver_types" rel="Chapter" href="Solver_types.html">
<link title="Solver" rel="Chapter" href="Solver.html">
<link title="Mcsolver" rel="Chapter" href="Mcsolver.html">
<link title="Tseitin" rel="Chapter" href="Tseitin.html">
<link title="Dot" rel="Chapter" href="Dot.html">
<link title="Coq" rel="Chapter" href="Coq.html">
<link title="Dedukti" rel="Chapter" href="Dedukti.html">
<link title="Backend_intf" rel="Chapter" href="Backend_intf.html">
<link title="Sat" rel="Chapter" href="Sat.html"><link title="Solving facilities" rel="Section" href="#2_Solvingfacilities">
<link title="Propositional models" rel="Section" href="#2_Propositionalmodels">
<link title="Proofs and Models" rel="Section" href="#2_ProofsandModels">
<link title="Internal data" rel="Section" href="#2_Internaldata">
<title>mSAT doc : Internal.Make</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="Internal.html" title="Internal">Up</a>
&nbsp;</div>
<h1>Functor <a href="type_Internal.Make.html">Internal.Make</a></h1>

<pre><span class="keyword">module</span> Make: <div class="sig_block"><code class="code">functor (</code><code class="code">St</code><code class="code"> : </code><code class="type"><a href="Solver_types.S.html">Solver_types.S</a></code><code class="code">) -&gt; </code><div class="sig_block"><code class="code">functor (</code><code class="code">Th</code><code class="code"> : </code><code class="type"><a href="Plugin_intf.S.html">Plugin_intf.S</a></code><code class="type">  with type term = St.term and type formula = St.formula and type proof = St.proof</code><code class="code">) -&gt; </code><div class="sig_block"><code class="code">functor (</code><code class="code">Dummy</code><code class="code"> : </code><code class="code">sig</code></pre><div class="sig_block"></div><pre><code class="code">end</code><code class="code">) -&gt; </code><code class="code">sig</code> <a href="Internal.Make.html">..</a> <code class="code">end</code></div></div></div></pre><table border="0" cellpadding="3" width="100%">
<tr>
<td align="left" valign="top" width="1%%"><b>Parameters: </b></td>
<td>
<table class="paramstable">
<tr>
<td align="center" valign="top" width="15%">
<code>St</code></td>
<td align="center" valign="top">:</td>
<td><code class="type"><a href="Solver_types.S.html">Solver_types.S</a></code>
<tr>
<td align="center" valign="top" width="15%">
<code>Th</code></td>
<td align="center" valign="top">:</td>
<td><code class="type"><a href="Plugin_intf.S.html">Plugin_intf.S</a> with type term = St.term and type formula = St.formula and type proof = St.proof</code>
<tr>
<td align="center" valign="top" width="15%">
<code>Dummy</code></td>
<td align="center" valign="top">:</td>
<td><code class="type">sig end</code>
</table>
</td>
</tr>
</table>
<hr width="100%">
<br>
Functor to create a solver parametrised by the atomic formulas and a theory.<br>
<br>
<h2 id="2_Solvingfacilities">Solving facilities</h2><br>

<pre><span id="EXCEPTIONUnsat"><span class="keyword">exception</span> Unsat</span></pre>

<pre><span id="EXCEPTIONUndecidedLit"><span class="keyword">exception</span> UndecidedLit</span></pre>

<pre><span id="VALsolve"><span class="keyword">val</span> solve</span> : <code class="type">unit -> unit</code></pre><div class="info ">
Try and solves the current set of assumptions.<br>
<b>Raises</b> <code>Unsat</code> if a toplevel conflict is found<br>
<b>Returns</b> () if the current set of clauses is satisfiable<br>
</div>

<pre><span id="VALassume"><span class="keyword">val</span> assume</span> : <code class="type">?tag:int -> St.formula list list -> unit</code></pre><div class="info ">
Add the list of clauses to the current set of assumptions.
      Modifies the sat solver state in place.<br>
</div>

<pre><span id="VALnew_lit"><span class="keyword">val</span> new_lit</span> : <code class="type">St.term -> unit</code></pre><div class="info ">
Add a new litteral (i.e term) to the solver. This term will
      be decided on at some point during solving, wether it appears
      in clauses or not.<br>
</div>

<pre><span id="VALnew_atom"><span class="keyword">val</span> new_atom</span> : <code class="type">St.formula -> unit</code></pre><div class="info ">
Add a new atom (i.e propositional formula) to the solver.
      This formula will be decided on at some point during solving,
      wether it appears in clauses or not.<br>
</div>

<pre><span id="VALpush"><span class="keyword">val</span> push</span> : <code class="type">unit -> unit</code></pre><div class="info ">
Create a decision level for local assumptions.<br>
<b>Raises</b> <code>Unsat</code> if a conflict is detected in the current state.<br>
</div>

<pre><span id="VALpop"><span class="keyword">val</span> pop</span> : <code class="type">unit -> unit</code></pre><div class="info ">
Pop a decision level for local assumptions.<br>
</div>

<pre><span id="VALlocal"><span class="keyword">val</span> local</span> : <code class="type">St.formula list -> unit</code></pre><div class="info ">
Add local assumptions<br>
</div>
<br>
<h2 id="2_Propositionalmodels">Propositional models</h2><br>

<pre><span id="VALeval"><span class="keyword">val</span> eval</span> : <code class="type">St.formula -> bool</code></pre><div class="info ">
Returns the valuation of a formula in the current state
      of the sat solver.<br>
<b>Raises</b> <code>UndecidedLit</code> if the literal is not decided<br>
</div>

<pre><span id="VALeval_level"><span class="keyword">val</span> eval_level</span> : <code class="type">St.formula -> bool * int</code></pre><div class="info ">
Return the current assignement of the literals, as well as its
      decision level. If the level is 0, then it is necessary for
      the atom to have this value; otherwise it is due to choices
      that can potentially be backtracked.<br>
<b>Raises</b> <code>UndecidedLit</code> if the literal is not decided<br>
</div>

<pre><span id="VALmodel"><span class="keyword">val</span> model</span> : <code class="type">unit -> (St.term * St.term) list</code></pre><div class="info ">
Returns the model found if the formula is satisfiable.<br>
</div>

<pre><span id="VALcheck"><span class="keyword">val</span> check</span> : <code class="type">unit -> bool</code></pre><div class="info ">
Check the satisfiability of the current model. Only has meaning
      if the solver finished proof search and has returned <code class="code">Sat</code>.<br>
</div>
<br>
<h2 id="2_ProofsandModels">Proofs and Models</h2><br>

<pre><span class="keyword">module</span> <a href="Internal.Make.Proof.html">Proof</a>: <code class="type"><a href="Res.S.html">Res.S</a></code><code class="type">  with module St = St</code></pre>
<pre><span id="VALunsat_conflict"><span class="keyword">val</span> unsat_conflict</span> : <code class="type">unit -> St.clause option</code></pre><div class="info ">
Returns the unsat clause found at the toplevel, if it exists (i.e if
      <code class="code">solve</code> has raised <code class="code">Unsat</code>)<br>
</div>

<pre><span id="VALfull_slice"><span class="keyword">val</span> full_slice</span> : <code class="type">unit -> (St.term, St.formula, St.proof) <a href="Plugin_intf.html#TYPEslice">Plugin_intf.slice</a></code></pre><div class="info ">
View the current state of the trail as a slice. Mainly useful when the
      solver has reached a SAT conclusion.<br>
</div>
<br>
<h2 id="2_Internaldata">Internal data</h2>
      These functions expose some internal data stored by the solver, as such
      great care should be taken to ensure not to mess with the values returned.<br>

<pre><span id="VALtrail"><span class="keyword">val</span> trail</span> : <code class="type">unit -> St.t Vec.t</code></pre><div class="info ">
Returns the current trail.
      *DO NOT MUTATE*<br>
</div>

<pre><span id="VALhyps"><span class="keyword">val</span> hyps</span> : <code class="type">unit -> St.clause Vec.t</code></pre><div class="info ">
Returns the vector of assumptions used by the solver. May be slightly different
      from the clauses assumed because of top-level simplification of clauses.
      *DO NOT MUTATE*<br>
</div>

<pre><span id="VALtemp"><span class="keyword">val</span> temp</span> : <code class="type">unit -> St.clause Vec.t</code></pre><div class="info ">
Returns the clauses coreesponding to the local assumptions.
      All clauses in this vec are assured to be unit clauses.
      *DO NOT MUTATE*<br>
</div>

<pre><span id="VALhistory"><span class="keyword">val</span> history</span> : <code class="type">unit -> St.clause Vec.t</code></pre><div class="info ">
Returns the history of learnt clauses, with no guarantees on order.
      *DO NOT MUTATE*<br>
</div>
</body></html>